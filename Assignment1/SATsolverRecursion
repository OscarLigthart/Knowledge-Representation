import itertools as it
import numpy as np
import random
import copy


def contains_empty_clause(problem):
    empty_clause = False
    for clause in tree.current_node.problem:
        if clause == []:
            empty_clause = True

    return empty_clause

def update_problem(problem, variable, var_assignment):
    """
        updates the problem after variable is set to a certain value
    """
    new_problem = []

    for clause in problem:
        new_clause = copy.deepcopy(clause)
        clause_satisfied = False
        for literal in clause:

            # if the variable appears in the clause
            if abs(literal) == variable:

                # if the variable appears as a neg. literal
                if literal < 0:

                    # and the variable is assigned to true, the outcome will be "not" true -> so false
                    if var_assignment == True:
                        # in that case the literal needs to be removed from the clause
                        new_clause.remove(literal)

                    # however, if the variable is assigned to false, the outcome will be "not" false -> so true
                    elif var_assignment == False:
                        # in that case the clause is satisfied
                        clause_satisfied = True
                # if the variable appears as a pos. literal
                else:

                    # and the variable is assigned to true, the outcome will be true
                    if var_assignment == True:
                        # in that case the clause is satisfied
                        clause_satisfied = True

                    # however, if the variable is assigned to false, the outcome will be false
                    if var_assignment == False:
                        # in that case the literal needs to be removed from the clause
                        new_clause.remove(literal)

        # if the clause is not satisfied, it will remain in the problem
        if not clause_satisfied:
            new_problem.append(new_clause)

    return new_problem

def update_purel_literal_dict(pure_literal_dict, variable, var_assignmen):
    pass


def unit_clause_simplification(problem, partial_assignment, pure_literal_dict):

    unit_clause_in_problem = True
    pure_literal_in_problem = True

    while (problem != [] and (unit_clause_in_problem or pure_literal_in_problem)):

        # check for pure literal

        for variable in pure_literal_dict:

            pos = pure_literal_dict[variable]["pos"]
            neg = pure_literal_dict[variable]["neg"]

            # check whether one of them is equal to 0:
            # if there are no positives, set the literal to false
            if pos == 0 and pos != neg:
                partial_assignment['false'].add(variable)
                update_problem(problem, variable, False)


            # if there are no negatives, set the literal to true
            elif neg == 0 and pos != neg:
                partial_assignment['true'].add(variable)
                update_problem(problem, variable, True)


        for clause in problem:
            if len(clause) == 1:

                literal = clause[0]

                if literal < 0:
                    partial_assignment["false"].add(abs(literal))
                    update_problem(problem, abs(literal), False)
                else:
                    partial_assignment["true"].add(abs(literal))
                    update_problem(problem, abs(literal), True)



        # if nothing has changed
            unit_clause_exists = False

    return problem, partial_assignment, pure_literal_dict



def recursive_DP(problem, partial_assignment, pure_literal_dict):

    # SIMPLIFY
    # problem, partial_assignment, pure_literal_dict = unit_clause_simplification(problem, partial_assignment, pure_literal_dict)

    #if contains empty clause: unsatisfied --> backtrack
    if problem == []:
        return partial_assignment # this is the result

    if contains_empty_clause(problem):
        # BACKTRACK

    else:
        # SPLIT






def SATsolver(sud_input, rules_input):
    '''
    This function takes as input the DIMACS format of a sudoku and the DIMACS format of the sudoku rules to correctly
    Solve a sudoku
    '''


    # get the set of clauses to satisfy
    problem = []
    nr_variables = ""
    nr_rules = ""
    with open(rules_input, 'r') as f:
        lines = f.read().splitlines()
        #TODO needs also the read in file with e.g. comments add start

        firstline = True

        # for each word in the line:
        for line in lines:

            if firstline:
                info = line.split()
                nr_variables = info[2]
                nr_rules = info[3]
                firstline = False
                continue

            rule = line.split()

            del rule[-1]

            rule = [int(i) for i in rule]

            problem.append(rule)


    ## REMOVE AFTER TEST
    problem = [[1, -2], [1, -3, 2], [3, 2, -1], [-2, -1, 3],[4, -1]] # test problem
    ## REMOVE AFTER TEST


    partial_assignment = {'true': set(), 'false': set()}


    # TODO GENERALIZE
    # the numbers where the Sudoku starts with are fixed and therefore always True

    ### TURN ON AGAIN AFTER TEST

    # with open(sud_input, 'r') as f:
    #     lines = f.read().splitlines()
    #
    #     for line in lines:
    #
    #         rule = line.split()
    #         del rule[-1]
    #
    #         for var in rule:
    #             partial_assignment['true'].add(int(var))

    variables = set(abs(var) for clause in problem for var in clause)

    variables_already_assigned = [(4, True)] # TEST DATA

    # update problem based on known variables
    for known_var in variables_already_assigned:
        var = known_var[0]
        var_assignment = known_var[1]

        problem = update_problem(problem, var, var_assignment)

        if var_assignment == True:
            partial_assignment["true"].add(var)
        elif var_assignment == False:
            partial_assignment["false"].add(var)


    # initialize a dict where pure literals are stored


    #TODO think about how to implement better datastrucure for pure literals
    pure_literal_dict = {}
    for var in variables:
        pure_literal_dict[var] = {"pos": 0, "neg": 0}


    new_problem = []


    # detect if there is a tautology
    for clause in problem:
        new_clause = copy.deepcopy(clause)

        clause_satisfied = False
        for literal in clause:

            # if the counter part of a literal is within the clause, there exists a tautology
            if (literal * - 1) in clause:
                # so clause will always be satisfied
                clause_satisfied = True

                break # no need to further investigate this literal in this clause since clause is already satisfied

            # keep track of positive and negative occurrences of variable. So we can find pure literals using the pure_literal_dict later on
            if literal > 0:
                pure_literal_dict[abs(literal)]["pos"] += 1

            elif literal < 0:
                pure_literal_dict[abs(literal)]["neg"] += 1

        # only keep the unsatisfied clauses
        if not clause_satisfied:
            new_problem.append(new_clause)

    problem = new_problem


    recursive_DP(problem, partial_assignment, pure_literal_dict)


    return


solution = SATsolver("output.txt", "sudoku-rules.txt")



        # ################################
        # # step 2, simplify using rules #
        # ################################
        #
        # # reset dictionary
        # for var in variables:
        #     pure_literal_dict[var] = {"pos": 0, "neg": 0}
        #
        # # keep track of what the new problem will hold
        # new_problem = []
        #
        # # loop through problem
        # for i, clause in enumerate(problem):
        #
        #     ##############################
        #     # unit clause simplification #
        #     ##############################
        #
        #     if len(clause) == 1:
        #         data = unit_clause_simplification(problem, data, i)
        #
        #     ###############################
        #     # Tautology and pure literals #
        #     ###############################
        #
        #     taut = False
        #     for literal in clause:
        #         # if the counter part of a literal is within the clause, there exists a tautology
        #         if (literal * - 1) in clause:
        #             taut = True
        #
        #         # keep track of positive and negative occurences of literals to find pure literals
        #         if literal > 0:
        #             pure_literal_dict[abs(literal)]["pos"] += 1
        #
        #         elif literal < 0:
        #             pure_literal_dict[abs(literal)]["neg"] += 1
        #
        #     if not taut:
        #         new_problem.append(clause)
        #
        # problem = new_problem
        #
        # # SANiTY CHECK FOR PURE LITERALS
        # """
        # for i, clause in enumerate(problem):
        #     for j, literal in enumerate(clause):
        #         if literal == 114:
        #             print(clause)
        #             print(i)
        #             print(count)
        # """

#
#        # loop through the pure literal dict to find whether we have pure literals
#         for literal in pure_literal_dict:
#
#             pos = pure_literal_dict[literal]["pos"]
#             neg = pure_literal_dict[literal]["neg"]
#
#             # check whether one of them is equal to 0:
#             # if there are no positives, set the literal to false
#             if pos == 0 and pos != neg:
#                 data['false'].append(literal)
#                 try:
#                     data['unk'].remove(literal)
#                 except:
#                     pass
#
#             # if there are no negatives, set the literal to true
#             elif neg == 0 and pos != neg:
#                 data['true'].append(literal)
#                 try:
#                     data['unk'].remove(literal)
#                 except:
#                     pass
#
#         data['false'] = list(set(data['false']))
#         data['true'] = list(set(data['true']))
#
#         # sanity check
#         # TODO, check if lists hold unique elements accross, element can't be true and false
#
#         ##############################
#         # step 3, split if necessary #
#         ##############################
#
#         # check if necessary
#         if len(problem) > 0:
#
#             # apply split
#             # pick random value from unknowns and set it to either true or false
#             if len(data['unk']) > 0:
#                 literal = random.choice(data['unk'])
#
#                 data['unk'].remove(literal)
#
#                 if random.random() >= 0.5:
#                     data['true'].append(literal)
#                     val = 1
#                 else:
#                     data['false'].append(literal)
#                     val = 0
#
#                 # save current state (as node)
#                 path.insert(root, data, problem, val, literal)
#
#             # if there are no more unknowns, traverse back through the tree and try different splits
#             else:
#                 # need a backtracking function for the tree
#                 path.traverseInorder(root)
#
#         else:
#             break
#
#         # check if dead end!
#         # might go wrong because of this? why?
#
#         ############################
#         # step 4, rinse and repeat #
#         ############################
#
#     print(len(data['true']))
#
#     return
#
#
# solution = SATsolver("output.txt", "sudoku-rules.txt")
#
# print(solution)
